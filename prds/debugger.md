# MCP Debugger Tab

## Overview

Add a first-class "Debugger" tab that lets operators explore and invoke MCP tools exposed by any connected upstream server. The tab gives visibility into a server's tools, allows crafting requests from JSON schema-driven forms, and renders responses inline. Activity originating from the debugger must also be attributable in the persistent RPC logs.

## Goals

- Surface a dedicated debugger workspace reachable from the existing Servers page.
- Limit debugger access to MCP servers that are currently connected.
- Provide a three-panel layout (tool list, request builder, response viewer) per the product brief.
- Automatically derive reasonable input controls from the tool's JSON schema while providing a safe fallback for unsupported shapes.
- Execute tool calls through the proxy and stream results back into the UI.
- Tag debugger-originated traffic in the logging pipeline so the Logs page can display its provenance.
- Cover the behavior with focused frontend and backend tests.

## Non-Goals

- Building a general-purpose JSON schema editor. We only need a pragmatic subset to cover common MCP tool schemas.
- Persisting debugger session state between application launches (state is in-memory only).
- Surfacing live streaming output; we handle the final tool response payload.

## User Stories

1. As an operator, I can open the debugger for a connected server directly from its server card.
2. As an operator, I can browse the server's tools, inspect descriptions, and trigger calls with tailored arguments.
3. As an operator, I see immediate feedback about request validation errors, tool-call success, or tool-call failure.
4. As an operator, I can tell on the Logs page which entries were generated by the debugger tab.

## UX / UI

### Entry Points

- Add a "Debug" pill button to `ServerCard` (right-hand action cluster). The button only renders when the server is enabled, in the `connected` state, and has at least one tool available. Clicking it switches the root tab to `Debugger` and pins the target server.
- The main header tab strip gains a fourth option labeled "Debugger". Selecting it shows the debugger workspace. The badge displays the number of connected servers that expose at least one tool (to reinforce the "connected-only" requirement).

### Workspace Structure

- Header: shows the active server name and transport badge. A dropdown allows switching to any other connected server without leaving the tab. If the previously selected server disconnects, the dropdown auto-selects the next connected server or falls back to an empty state.
- Layout: responsive CSS grid with three primary panels:
  - Left (25% width, scrollable): list of tools for the active server. Includes a search filter, per-tool description preview tooltip, and visual indicator for the currently selected tool.
  - Right / Top (remaining width, 50% of viewport height min): "Request" panel containing the schema-driven form plus a toggle to switch between Form and Raw JSON modes.
  - Right / Bottom: "Response" panel showing the most recent invocation. When no invocation has occurred, render guidance text. On error, show structured error details and highlight in red.

### Tool List Behavior

- Fetch via `MCPService.GetClientTools(serverName)` on initial load and on explicit refresh.
- Render each tool name, optional description snippet, and any schema availability badge (e.g., "schema" when `input_schema` is present).
- Provide a "Refresh tools" button; reuse the existing `MCPService.RefreshClientTools` then re-fetch the list.

### Input Panel

- Default to Form mode when the schema is a JSON Schema v7 object with only primitive properties (string, number/integer, boolean, and arrays of primitives). Nested objects, oneOf/allOf, enums, or unsupported constructs automatically trigger Raw JSON-only mode with a heads-up message.
- Form mode requirements:
  - Generate labeled controls per property; required fields show an asterisk.
  - Basic validation: enforce required properties and primitive type coercion; show inline errors before submission.
  - Arrays render as dynamic lists with add/remove row controls.
  - Provide helper text sourced from the property's `description` when present.
- Raw JSON mode: text area seeded with the last valid payload; validate against schema (when available) on submission and surface parse errors.
- Include "Reset" to clear the current request back to schema defaults and "Call Tool" primary action.

### Output Panel

- Show a timestamped summary chip (status + duration) once a response arrives.
- Render structured content as pretty-printed JSON using the existing `HighlightedJson` component. When MCP `content` array includes text segments, show them in order before the JSON block.
- On error (`is_error === true`), highlight headers in red and expose the error string.

### Empty States & Errors

- No connected servers: display guidance explaining that the debugger activates once servers connect.
- Connected server with zero tools: empty-state illustration informing the operator.
- Lost connection mid-session: disable form submission, show banner, and prompt to return to Servers tab.

## Data & API Changes

### Frontend â†’ Backend Bridge

- Add `MCPService.DebugCallTool(serverName: string, toolName: string, args: Record<string, unknown>)` that invokes a new Tauri command.
- Extend TabSwitcher types (`TabKey`) to include `'debugger'`.

### Tauri Command

- Implement `mcp_debug_call_tool` in `src-tauri/src/main.rs`:
  - Validate the server exists, is enabled, and currently marked connected in the overlay snapshot; otherwise return a structured error.
  - Ensure the debugger session reuses the standard rmcp client (no duplicate connections).
  - Wrap the call in a request-origin scope (see logging changes below) so downstream transports tag the event origin as `debugger`.
  - Return both the `CallToolResult` and round-trip metadata (duration, request echo) to the frontend.

### Logging Pipeline

- Extend `logging_core::Event` with an optional `origin: Option<String>` field.
- Update SQLite persistence to store a new `origin` TEXT column (create migration `0002_logging_add_origin.sql`). Ensure reads default to `NULL` when the column is absent.
- Teach `InterceptingTransport` (inbound) to default origin to `external` and `InterceptingClientTransport` (outbound) to default to `internal`.
- Introduce an async scope helper (task-local) that lets the debugger command annotate outbound requests with `origin = "debugger"`; `OutboundInterceptState::build_pending` reads the scoped origin and stamps `event.origin` plus appends the origin prefix to the session id (`debugger::<server>`).
- Emit a matching origin value when the debugger command logs the local synthetic "tools/call" event (so Logs view shows coherent provenance).
- Update `sqlLoggingService` types and queries to hydrate the new column and expose it via `RpcLog`.
- Logs page: display a colored chip next to the method when `origin` is present (Debugger, Internal, External, etc.).

## Form Schema Handling

- Support properties with `type: "string" | "number" | "integer" | "boolean"`.
- Support arrays whose `items` is a primitive schema from the previous bullet.
- Respect `default` values when provided by the schema.
- For unsupported constructs, disable form mode with an explicit message and rely on raw JSON editing.

## Validation & Edge Cases

- Guard the debugger tab against stale selections: if the selected server disappears from the current settings or transitions away from `connected`, drop back to the empty state.
- Debounce tool search input to avoid re-render storms on large tool lists.
- Ensure the Debug button is keyboard accessible and announced with an aria-label.
- Loading states: spinners while fetching tools, disabled call button while execution is in flight.

## Testing Strategy

- **Frontend** (Vitest + RTL):
  - Render the Debugger tab with mock connected servers and verify empty states, tool selection, form rendering, and submission wiring.
  - Exercise validation (missing required field, JSON parse error) and success path (mocked backend response populates output panel and disables spinner).
  - Verify Logs UI badge rendering logic when `origin = "debugger"`.
- **Backend** (Rust):
  - Unit test the request-origin scope helper to ensure events created inside the scope carry `origin = "debugger"` and session id prefix `debugger::`.
  - Extend SQLite logging tests to cover the new column migration and round-trip.
  - Test `mcp_debug_call_tool` happy path and rejection when the server is disconnected.

## Follow-Ups / Open Questions

- Future iteration: stream partial tool responses into the output panel.
- Consider persisting recent invocations per server so operators can recall payloads.
- Evaluate whether we should deduplicate debugger vs. general internal clients at the transport layer after beta feedback.

